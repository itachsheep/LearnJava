package com.tencent;

public class _18_哈夫曼编码 {
    public static void main(String[] args) {

    }
    /**
     * 以英文字母小写a为例, ASCII编码中，十进制为97，二进制为01100001。
     * ASCII的每一个字符都用8个Bit(1Byte)编码，假如有1000个字符要传输，
     * 那么就要传输8000个Bit。问题来了，英文中字母e的使用频率为12.702%，
     * 而z为0.074%，前者是后者的100多倍，但是确使用相同位数的二进制。
     * 可以做得更好，方法就是可变长度编码，指导原则就是频率高的用较短的位数编码，
     * 频率低的用较长位数编码。Huffman编码算法就是处理这样的问题。
     *
     *
     *
     * 1，需要个优先级队列
     * 2，统计数据，频率的统计信息，转为Map<Character,Integer>即可
     * 3，构建树，构建树是Huffman编码算法的核心步骤。
     * 思想是把所有的字符挂到一颗完全二叉树的叶子节点，
     * 任何一个非页子节点的左节点出现频率不大于右节点。
     *
     * 4，编码
     * 某个字符对应的编码为，从该字符所在的叶子节点向上搜索，如果该字符节点是父节点的左节点，
     * 编码字符之前加0，反之如果是右节点，加1，直到根节点。
     * 只要获取了字符和二进制码之间的mapping关系，编码就非常简单。
     *
     * 原文链接：https://blog.csdn.net/kimylrong/java/article/details/17022319
     */
}
